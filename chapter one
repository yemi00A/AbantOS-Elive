The chapter one
The most effective way to understand how an operating system works is through abstraction- a fancy way of saying that you can ignore most of the details. There are many terms for an abstracted sub-division in computer software but we’ll use the term component in this chapter because it’s simple.  
Level and layers of Abstraction in a Linux system. Using abstraction to split computing systems into component makes thing easier to understand, but it doesn’t work without organization. Web browsers, games and such sit at the top layer, at the bottom layer we have memory in the computer hardware-  the 0s and 1s. The operating system occupies most of the layers in between.
A Linux system has three main level. The hardware is at the base. The next level is the kernel, which is the core of the operating system. The kernel is software residing in memory that tell the CPU what to do. The kernel manages the hardware and acts primarily as an interface between the hardware and any running program. 
Nearly everything that the kernel does revolves around the main memory. The kernel is in charge of managing task in four general system area. Which are the following: process, memory, device driver and system calls and support. 
Hardware: of all the hardware on a computer system, main memory is perhaps the most important. In its most raw form, main memory is just a big storage area for a bunch of 0s and 1s. A CPU is just an operator on memory, it reads its instructions and data from the memory and writes data back out to the memory.
The kernel also supports user process with features other than traditional system calls, the most common of which are pseudodevices. 
The main memory that the kernel allocates for user processes is called user space.
Basic services are at the bottom level, utility services are in the middle, and applications that user touch are at the top.
The kernel’s role with devices is pretty simple. A device is typically accessible only in kernel mode because improper access could crash the machine. 
There are several other kinds of kernel features available to user process. For example, system calls (or systcalls) perform specific task that a user processes alone cannot do well or at all.
Two system calls, fork() and exec(), are important to understanding how processes start up.
Other than init, all user processes on a linux system start as a result of fork(), and most of the time, you run exec() to start a new program instead of running a copy of an existing process.
System calls are normally denoted with parentheses. Process management describes the starting, pausing, resuming, and terminating of processes. The concepts behind starting and terminating processes are fairly straight forward, but describing how a process uses the CPU in its normal course of operation is a bit more complex. On any modern operating system, many processes run “simultaneously. However, things are not as they appear: The process behind these application typically do not run at exactly the same time.The processes run the CPU in turns. The act of one process giving up control of the CPU to another process is called a context switch.
 Each of time- called time slice- gives a process enough time for significant computation. 
The kernel is responsible for context switching. To understand how this works, let’s think about a situation in which a process is running in user mode but its time slice is up.
In the case of a multi-CPU system, things become slightly more complicated because the kernel doesn’t need to relinquish control of its current order to allow a process to run on a different CPU.
Because the kernel must manage memory during a context switch, it has a complex job of memory management. 
Fortunately for the kernel, there is help. Modern CPUs include a memory management unit(MMU) that enables a memory access scheme called visual memory. When using virtual memory, a process does not directly access the memory by its physical location in the hardware. Instead, the kernel sets up each process to act as if it had an entire machine to itself. When the process accesses some of its memory, the MMU intercepts the access and uses a memory address map to translate the memory location from the process into an actual physical memory location on the machine.  The kernel must still initialize and continuously maintain and alter this memory address map. For example, during a context switch, the kernel has to change the map from the outgoing process to the incoming process. The implementation of memory address map is called a page table
